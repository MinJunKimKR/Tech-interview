# OS

## 프로세스

### 프로세스란?

- 프로세스(process)란 실행중에 있는 프로그램(Program)을 의미한다.
- 스케줄링의 대상이 되는 작업(task)과 같은 의미로 쓰인다.
- 프로세스 내부에는 최소 하나의 스레드(thread)를 가지고있는데, 실제로는 스레드(thread)단위로 스케줄링을 한다.

### 프로세스와 스레드의 차이는 무엇인가요?

- 프로세스는 컴퓨터에서 실행중인 프로그램을 말하고 고유한 공간과 자원을 할당 받아 사용합니다.
- 스레드는 프로세스 안에서 실행되는 여러 흐름의 단위로 프로세스 내의 자원을 공유하고 고유한 stack만을 각자 할당 받습니다.

### 프로세스와 프로그램의 차이는 무엇인가요?

- 프로그램에는 생명이 없다. 그렇기에 프로그램에 자원이 할당받고, 메모리에 적재가 되면, 그때 프로세스가 되는것이다.

## 스레드

### 스레드란?

- 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위.

### 멀티 프로세스랑 멀티 스레드의 차이점은?

- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 가지고 있다.

- 반면, 멀티 프로세싱 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다.

## 컨텍스트 스위칭(Context Switching)이란 무엇인가요?

- 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스, 스레드)의 상태를 PCB에 저장하고 다음에 진행할 Task의 상태값을 읽어 적용하는 과정을 말한다.

## 컨텍스트 스위칭의 과정

- Task의 대부분 정보는 Register에 저장되고 PCB로 관리된다.
  - PCB(Process Control Block)란?
    OS가 프로세스 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 구조체이다.
- 현재 실행하고 있는 Task의 PCB 정보를 저장한다.
- 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

## CPU

### CPU 스케줄링이란?

- CPU 스케줄링이란 CPU를 배정하는 것을 말한다.
- 성능 척도 : 소요시간, 처리량, 사용률, 대기 시간, 응답 시간

- 선점 스케줄링 : OS가 CPU의 사용권을 빼앗을 수 있음
- 비선점 스케줄링 : CPU를 빼앗을 수 없음

## 교착상태(Dead Lock)

### 교착상태(Dead Lock)란 무엇인가?

- 교착 상태는 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제이다.
  서로 원하는 자원이 상대방에게 할당되어 있어 두 프로세스가 무한정 wait 상태에 빠지게 되는 상황.

### 교착상태가 발생하기 위한 조건은?

    4가지 중 하나라도 성립하지 않으면 데드락은 발생하지 않습니다.

- 상호 배제(Mutual exclusion) : 자원은 한번에 한 프로세스만 사용할 수 있음
- 점유 대기(Hold and wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
- 비선점(No preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
- 순환 대기(Circular wait) : 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

### 교착상태의 해결법은 무엇인가요?

- 예방(prevention)

  교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)

  - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
  - 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
  - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
  - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

- 회피(avoidance)

  교착 상태 발생 시 피해나가는 방법

  은행원 알고리즘(Banker's Algorithm)

  은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함

  프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있으면 자원할당, 아니면 할당을 거부하고 다른 프로세스 들이 자원을 해지할때까지 대기하는 방법

- 탐지(Detection)

  은행원 알고리즘과 유사한 방식 vs 자원 할당 그래프를 통해 교착 상태를 탐지함
  자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함

- 회복(Recovery)

  교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

  프로세스 종료 방법

  - 교착 상태의 프로세스를 모두 중지
  - 교착 상태가 제거될 때까지 하나씩 프로세스 중지

  자원 선점 방법

  - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
  - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

- 무시

### 회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.

은행원 알고리즘은 은행에서 현금을 할당하는 것에서 유래한 알고리즘입니다.

프로세스가 자원을 요구할때 자원을 할당한 후에도 안정 상태이면 자원을 할당하고, 그렇지 않으면 다른 자원이 해제될때까지 대기했다가 자원을 할당합니다.

### 은행원 알고리즘의 단점

- 할당할 수 있는 자원수가 일정 해야함
- 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다
- 최대 자원 요구량을 미리 알아야 한다.
- 프로세스들은 유한한 시간 안에 자원을 반납해야 한다.
