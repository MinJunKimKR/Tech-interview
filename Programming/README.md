# 프로그래밍

## Javascript

### 특징과 구조에 대해 설명해주세요

- 비동기로 처리한다.
- 메모리 힙과 콜 스택으로 되어있다.
- 싱글스레드 언어이다.
  - 하지만 브라우저 혹은 Node.js에 있는 이벤트 루프로 인해 비동기 처리가 가능하다.
  - 즉, 자바스크립트 엔진에는 이벤트루프가 존재하지 않는다.
  - 브라우저는 멀티스레드로 동작한다.

## Node.js

### 정의

- 크롬 V8엔진으로 빌드된 자바스크립트 런타임 환경이다.

### 철학

1. 경량 코어

   코어를 최소의 기능 세트로 하고, 나머지를 소위 사용자의 몫으로 해서, 핵심 모듈의 바깥 영역 모듈들을 생태계에 맡기는 것.
   핵심 기능 세트를 최소한으로 유지하면, 유지보수 측면에서 편리할 뿐만 아니라 전체 생태계의 발전에 긍정적인 문화적 영향을 가져올 수 있습니다.

2. 경량 모듈

   모듈 개념을 프로그램 코드를 구성하는 기본 수단으로 사용합니다.
   어플리케이션과 패키지라고 하는 재사용 가능한 라이브러리를 만들기 위한 조립용 블록입니다.
   코드 크기뿐만 아니라 범위적인 면에서도 작은 모듈을 설계하는 것입니다.

   작은 모듈은 재사용성뿐만 아니라 다음과 같은 장점을 가집니다.

   - 이해하기 쉽고 사용하기 쉽다.
   - 테스트 및 유지보수가 훨씬 간단하다.
   - 브라우저와 완벽한 공유가 가능하다.

3. 작은 외부 인터페이스

   최소한의 기능을 노출하는 특성을 가지고 있습니다.
   여기서 가장 큰 이점은 API의 유용성이 향상된다는 것입니다.
   즉, API 사용이 보다 명확해지고 잘못된 사용에 덜 노출됩니다.

   모듈을 정의하는 가장 일반적인 패턴은 함수나 생성자와 같이 하나의 핵심 기능을 표현하는 동시에, 더 많은 고급 기능이나 보조 기능은 노출된 함수나 생성자의 속성이 되도록 하는 것입니다.

4. 간결함과 실용주의

   단순한 설계는 여러 가지 이유로 완벽한 모든 기능을 가진 소프트웨어에 비해 훌륭한 원칙이 됩니다. 구현하는데 소요되는 노력과 자원을 적게 사용하여 더 빨리 보급할 수 있고 적용과 유지보수 및 이해가 쉽습니다.
   이러한 요인들은 커뮤니티의 기여도를 높이고, 소프트웨어 자체가 성장하고 향상될 수 있도록 합니다.

   Node.js에서 이 원칙은 매우 실용적인 언어인 JavaScript에 의해 가능합니다.
   실제로 복잡한 클래스 계층 구조를 대체하는 간단한 함수(functions), 클로저(closures) 및 객체 리터럴(Object litrerals)을 사용하는 것을 흔히 볼 수 있습니다.
   합리적 수준의 복잡성을 가지고 더 빨리 작업하는 것이 더 큰 성공입니다.

   예를 들어, 싱글톤(singleton)이나 데코레이터(decorator)와 같은 상당 수의 전통적인 디자인 패턴은 사소하고 완벽하지 않은 구현이라도 간단히 사용될 수 있으며, 복잡하지 않고 실용적인 접근법(대부분의 경우)이 원칙적이고 완벽한 디자인보다 더 선호된다는 것을 보게 될 것입니다.

## Fastify

## Nest.js

## Express

## GraphQL

## Rest API

## Hasura

# 개념

## Class와 Interface, 객체란?

- Class
  - 객체를 만들어내기 위하여 상태와 행위(method)를 정의한 틀이다.
- Interface
  - 개발에서 청사진의 역할을 한다.
- 객체
  - 상태와 행위(method)를 가지고 있는 실체가 있는 데이터이다.

## Interface를 사용하는 이유는?

1. 결합도를 낮출수 있다.
2. 테스트의 용이성이 있다.
3. 개발을 독립적으로 할수있다.

- 추상 클래스의 다른점
  - 다중상속이 가능하다
  - 상태와 행위가 미완성 상태이다.

## DI란?

- 자기자신내에서 Class를 정의하는것이 아닌, 외부에서 객체를 주입하는 방법이다.
  - 생성자에서 Interface를 사용해서 객체를 매개변수로 받아서 사용할수 있게 만드는것이다.
- 이것을 사용하면 결합도를 낮출수있다.

## SOLID원칙이란?

### Single responsibilty

- 단일책임 원칙
- 객체 혹은 펑션은 한가지의 기능만 책임을 져야한다.

### Open-close

- 열림- 닫힘 원칙
- 확장에는 열려있어야 하지만, 변경하는것에는 닫혀있어야 한다.

### Liskov Substitution

- 리스코프 치환 원칙
- 객체의 상위타입의 객체를 하위타입의 객체로 사용해도 정상적으로 작동해야한다.
  - 객체의 상위타입 명세가 하위타입에서 적용될때에만 상속을 해야한다.

### Interface Segrearion

- 인터페이스 분리 원칙
- 인터페이스는 반드시 하나의 일을 해야 하며, 추가적인 행위는 반드시 별개의 인터페이스로 분리해서 추상화 시켜줘야한다.

### DI

- 의존성 역전
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
