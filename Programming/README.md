# Javascript

**Reference list**

- https://velog.io/@wkahd01/프론트엔드-면접-문제-은행-HTML-질문-답변

- 코어자바스크립트: http://www.yes24.com/Product/Goods/78586788

### 특징과 구조에 대해 설명해주세요

- 비동기로 처리한다.
- 메모리 힙과 콜 스택으로 되어있다.
- 싱글스레드 언어이다.
  - 하지만 브라우저 혹은 Node.js에 있는 이벤트 루프로 인해 비동기 처리가 가능하다.
  - 즉, 자바스크립트 엔진에는 이벤트루프가 존재하지 않는다.
  - 브라우저는 멀티스레드로 동작한다.

### JS엔진 구조를 설명해주세요

- 크게 메모리 힙과 콜스택으로 되어있다.
- 메모리힙에는 실제 코드와 데이터를 할당받아져 있는 객체들이 존재하며 GC 작업을 처리한다.
  - 메모리 힙에는 new space와 old space가 존재한다. 그리고 code가 올라가는 code space, 큰 obejct가 올라가는 large object space등이 있다.
- 콜스택에는 실행한 함수가 적재되며, 하나씩 실행이 된다.
  - 이때 비동기 작업이 발생을 하게되면, '브라우저 혹은 노드에 있는' 테스크 큐와 이벤트 루프를 사용하여 처리하게 된다.

### 이벤트루프를 설명해 주세요

- 이벤트루프가 자바스크립트의 비동기 작업을 가능하게 해준다.
- 자바스크립트의 비동기 작업이 일어날경우 (I/O, setTimeOut ...) 콜스택에서 실행되면, 라이브러리를 통하여 테크스큐에 쌓이게된다.
- 이벤트루프는 지속적으로 자바스크립트의 콜스택을 바라보며 비어질때까지 기다린다.
- 이후 자바스크립트의 콜스택이 비게되면, 테스크큐의 작업을 하나씩 콜스택에 밀어넣어주게된다.
- 이로서 자바스크립트가 싱글스레드임에도 비동기처리가 가능한 이유다.

### 매크로 테스크

- 이벤트 루프에서 일반 비동기 함수가 쌓이는 큐이다. 우리가 흔히 이벤트 루프로 생각하는것이 이 매크로 테스크다.

### 마이크로 테스크

- promise와 같은 흐름제어문의 경우, 마이크로 테스크로 작업이 들어가게된다. 이때, 마이크로 테스크는
  매크로 테스크보다 작업의 우선순위를 가지게된다.
- 즉, 매크로 테스크와 마이크로 테스크가 있을경우 마이크로 테스트가 먼저 이벤트루프에 의해 콜스택으로 들어가게된다.

### promise와 async의 차이

**promise**

then에 해당하는 부분이 micro task로 가게 되지만,promise가 실행이된 body자체는 계속해서 진행을 한다

**async**

await가 발생하게되면, await하위의 모든 작업들이 micro task로 가게된 다음, await작업이 완료되면 진행이 된다는점이 다르다.

### GC에 대해 설명해주세요

- 메모리힙에는 new space와 old space가 존재한다. 그리고 code가 올라가는 code space, 큰 obejct가 올라가는 large object space가 있다.
- 먼저 객체가 생성이되면 우선 new space에 저장이된다.
  - new space에는 to semi sapce와 from semi space가 존재한다.
  - 그중 to semi space에 우선적으로 저장이된다.
  - 어느순간 꽉차게되면, minor GC가 작동한다.
  - 그후 2번의 minorGC를 거친 객체는 old space로 이동된다.
- old space는 2개의 space가 존재하는데, pointer와 data로 나뉘어져있다.
  - pointer space는 다른 객체를 참조하는 객체가, data space는 데이터만 가진 객체가 저장된다.
  - 어느순간 꽉차게 되면 major GC가 작동한다.

### 변수 스코프체이닝에 대해서 아시나요?

- **스코프가 계층적으로 연결된 것을 스코프 체인** *scope chain* 이라 한다
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 **변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색** 한다

### Prototype이란? 그리고 그 사용예시는?

### 클로저란?

함수의 중첩이 되어있는 상황에서, 외부함수가 종료가 되었음에도
내부함수로 인하여 외부함수의 변수에 접근가능한 이러한 함수를 클로저라한다.

이때, 클로저를 이용하여 캡슐화를 실현할수있다.

```
function closureF(){
  let name = 'jamong';
  return function(){
    return name;
  };
}
let closure = closureF();
console.log(closure()); // 'jamong' 출력
```

## this

### this란?

- this는 함수를 호출할때 결정된다.
  - 즉, 함수를 어떤 방식으로 호출하느냐에 따라 값이 달라진다.
- 전역공간에서의 this
  - 전역객체를 가리킨다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역객체이기 때문이다.
    - 브라우저에서는 window고, node에서는 global이다.
- 함수와 매소드에서의 this
  - 함수에서의 this는 전역 컨텍스트를 나타낸다. 이유는 자바스크립트의 모든 요소는 전역컨텍스트의 프로퍼티로 생성이 되기 때문이다.
  - 하지만, 객체안에 담기는 매소드의 경우는 선언한 객체의 프로퍼치를 나타낸다.
- 매소드 내부의 this
  - 어떤 함수를 매소드로 호출하는 주체는 함수명 앞의 객체입니다.
    즉, 마지막의 명시된 객체가 곧 this가 된다.
- arrow function의 this
  - arrow funtion은 this를 가지지 않기 때문에 상위 스코프의 this를 그대로 사용한다.
- callback 함수에서의 this
  - callback 함수에서의 this는 사용법에 따라 달라지기 때문에 명확히 알수가 없다.
  - 만일 객체에서 callback을 사용했다면 위의 매소드의 this와 같이 호출한 주체를 this로 가리킨다.
- 생성자 함수 내부의 this
  - 객체지향에서 생성자를 class, class를 통해 만든 객체를 인스턴스라고 한다.
  - 생성자는 구체적인 인스턴스를 만들기 위한 일종의 틀이다.
  - 생성자를 호출하면 prototype 프로퍼티를 참조하는 객체를 만들고, this는 생성자를 통해 만들어진 이러한 인스턴스를 바라본다.

### this의 우회방법

```
var obj = {
  outer : function(){
    console.log(this) // {outer : f}
    var inner1 = function(){
      console.log(this) // window {...}
    }
    inner1();

    var self = this
    var inner2 = function(){
      console.log(self) // {outer : f}
    }
    inner2()
  }
}
obj.outer();
```

위와 같은 코드로 this를 상위 스코프에서 self라는 변수에 할당한다.
이후, 내부에서 사용하는것 만으로 this 문제를 해결할수있다.

### 함수와 매서드의 차이

함수는 function혹은 arrow function으로 선언이된것을 함수라고 합니다.
이때 자바스크립트는 변수의 값으로 함수를 사용할수 있습니다.

만일, 어느 객체의 속성값으로 함수를 담아서 사용한다면 이것을 매소드라고 한다.

### arrow function과 그냥 function의 차이

arrow function는 스스로의 this와 argument를 가지지 않는다.

즉, 화살표 arrow function 내부의 this는 상위 스코프의 this를 그대로 사용이 가능하다.

# Node.js

## 정의

- 크롬 V8엔진으로 빌드된 자바스크립트 런타임 환경이다.

## 철학

1. 경량 코어

   코어를 최소의 기능 세트로 하고, 나머지를 소위 사용자의 몫으로 해서, 핵심 모듈의 바깥 영역 모듈들을 생태계에 맡기는 것.
   핵심 기능 세트를 최소한으로 유지하면, 유지보수 측면에서 편리할 뿐만 아니라 전체 생태계의 발전에 긍정적인 문화적 영향을 가져올 수 있습니다.

2. 경량 모듈

   모듈 개념을 프로그램 코드를 구성하는 기본 수단으로 사용합니다.
   어플리케이션과 패키지라고 하는 재사용 가능한 라이브러리를 만들기 위한 조립용 블록입니다.
   코드 크기뿐만 아니라 범위적인 면에서도 작은 모듈을 설계하는 것입니다.

   작은 모듈은 재사용성뿐만 아니라 다음과 같은 장점을 가집니다.

   - 이해하기 쉽고 사용하기 쉽다.
   - 테스트 및 유지보수가 훨씬 간단하다.
   - 브라우저와 완벽한 공유가 가능하다.

3. 작은 외부 인터페이스

   최소한의 기능을 노출하는 특성을 가지고 있습니다.
   여기서 가장 큰 이점은 API의 유용성이 향상된다는 것입니다.
   즉, API 사용이 보다 명확해지고 잘못된 사용에 덜 노출됩니다.

   모듈을 정의하는 가장 일반적인 패턴은 함수나 생성자와 같이 하나의 핵심 기능을 표현하는 동시에, 더 많은 고급 기능이나 보조 기능은 노출된 함수나 생성자의 속성이 되도록 하는 것입니다.

4. 간결함과 실용주의

   단순한 설계는 여러 가지 이유로 완벽한 모든 기능을 가진 소프트웨어에 비해 훌륭한 원칙이 됩니다. 구현하는데 소요되는 노력과 자원을 적게 사용하여 더 빨리 보급할 수 있고 적용과 유지보수 및 이해가 쉽습니다.
   이러한 요인들은 커뮤니티의 기여도를 높이고, 소프트웨어 자체가 성장하고 향상될 수 있도록 합니다.

   Node.js에서 이 원칙은 매우 실용적인 언어인 JavaScript에 의해 가능합니다.
   실제로 복잡한 클래스 계층 구조를 대체하는 간단한 함수(functions), 클로저(closures) 및 객체 리터럴(Object litrerals)을 사용하는 것을 흔히 볼 수 있습니다.
   합리적 수준의 복잡성을 가지고 더 빨리 작업하는 것이 더 큰 성공입니다.

   예를 들어, 싱글톤(singleton)이나 데코레이터(decorator)와 같은 상당 수의 전통적인 디자인 패턴은 사소하고 완벽하지 않은 구현이라도 간단히 사용될 수 있으며, 복잡하지 않고 실용적인 접근법(대부분의 경우)이 원칙적이고 완벽한 디자인보다 더 선호된다는 것을 보게 될 것입니다.

# Node.js framework

## Fastify

### 왜 Nest를 사용했는지 (장,단점)

## Nest.js

### 왜 Nest를 사용했는지 (장,단점)

## Express

# API

**Reference list**

- Hasura: https://hasura.io/
- Architecture of a high performance GraphQL to SQL engine : https://hasura.io/blog/architecture-of-a-high-performance-graphql-to-sql-server-58d9944b8a87/
- https://hasura.io/blog/how-hasura-works/

## GraphQL

reference list

- https://chanyeong.com/blog/post/53
- https://yeolceo.tistory.com/114

### GraphQL의 정의(철학)을 말씀해주세요

### 동작 방식에대해 설명해주세요

### 장,단점에 대해 말씀해주세요

#### 큰 기업은 왜 안쓸까?

### GraphQL API와 REST API의 차이점에대해 말씀해주세요

### N+1문제란? 그리고 그 해결방법은?

- query를 작성할때 서브쿼리의 값을 가져오기 위해서는 1개의 쿼리 그리고 각각 연결되어져있는 서브 쿼리를 다 가져와야 하기 때문에 1번의 요청이 N개를 가져온다 해서 1+N입니다.

  즉, 내부 객체를 얻기 위해 외부 객체에서 N개의 쿼리를 만드는 경우를 말한다.

- 해결은 데이터 로더를 사용해서 N+1문제를 해결한다

### 데이터 로더란?

DataLoader는 Facebook에서 개발했으며 일괄 처리 및 캐싱을 통해 데이터베이스 또는 웹 서비스와 같은 다양한 원격 데이터 소스 요청에 대한 비용을 줄이는 기능을 한다. 즉, 성능 최적화를 위한 도구이다.

DataLoader는 크게 2가지 특징을 가지고 있다.

1. batch
   n+1에 대한 문제를 해결해 주는 것이 batch이다.

   GraphQL에서 Sub-Query를 통해 데이터를 호출할 때의 프로세스입니다.

   API 호출 시 Query를 통해 데이터를 반환합니다. Sub-Query는 반환되는 데이터중 하나를 key로 하여 새로운 쿼리를 호출하고 기존 key의 위치에 Sub-Query의 데이터를 반환합니다.

   이를 데이터 로더는 load 함수를 통해 **Sub-Query에서 사용할 key를 배열에 모아서 데이터 로더 함수에 전달합니다.** key값을 이용해 얻은 **객체를 조건에 맞게 반환해줍니다.**

   조건은 2가지이며 key배열과 동일한 길이의 배열을 반환하는 것과 기존의 key와 알맞은 위치 즉 , 동일한 index에 key로 얻은 결과인 객체를 반환해야 합니다.

2. cache

   데이터 로더를 사용해 호출한 함수 별로 캐시가 생성됩니다.

   자체적으로 CacheMap을 가지고 있습니다.

   캐시가 한번 생성되면 동일한 호출이 반복될 경우 DB에 접속하지 않고 메모리에 있는 값을 반환하여 리소스 낭비를 줄입니다.

   단 호출하는 **API의 매개변수가 자주 변경된다면 많은 Cache를 계속해서 맵핑할 수 있기 때문에 이 부분도 낭비**가 될 수 있습니다.

   잘 고려하여 사용하거나 캐시 생성 기능을 사용하지 않는 것이 방법이 될 수 있습니다.

## Hasura

### 철학이 어떤것인가요?

어플리케이션을 전과 다를정도로 빠르게 만드는것.
보통 data에 접근해야하는 api를 만드는데 많은 시간이 걸리는데, 이것을 효과적으로 줄이는것이 미션이다.

### Hasura 란?

Hasura는 실시간 실시간 GraphQL API 엔진입니다

> Hasura is the instant realtime GraphQL APIs engine

Postgresql뿐만 아니라 RestAPI, GraphqlAPI서버등을 연결하여 통합적인 realtime GraphQL API를 제공합니다.

### 왜 썼고 이득이 있었나요?

- 굉장히 빠른속도를 낸다. benchmark기준으로 Prisma나 postgraphile보다 훨씬 빠르다.
- 빠르게 적용해서 프론트앤드에 많은 자율성을 줄수가 있다.
- 통합 graphql 엔진이기에 확장성이 뛰어나다.
- auth나 cron job등을 console을 사용해서 파워풀하게 사용이 가능하다.
- 이로인해서 MVP로 단 2달이란 시간만에 런칭이 가능했다.

### N+1 문제 해결

Hasura는 JIT로 컴파일되어서 graphql을 sql로 만들어준다.
이떄, Hasura는 grapgql의 서브 쿼리를 sql의 join을 사용하여 sql문으로 만들게 되는데,
JSON aggregation functions을 사용해서 최적화를 진행한다.

### Pagnation 구현은 어떻게 하는가

- Hasura에서 limit, offset이라는 operator를 사용할수 있는데, 이것을 사용하면 몇개를, 몇번쨰부터 데이터를 가져올수 있게 한다.

## Rest API

### RestAPI정의

REST 기반으로 서비스 API를 구현한 것

- REST API는 HTTP 표준을 기반으로 구현됨

### Rest란?

REST(Representational State Transfer)

자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것

- HTTP URI를 통해 자원을 명시한다.
- HTTP 메서드(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD를 적용하는 것
  - 즉, 자원 기반의 구조 설계의 중심에 자원이 있고, HTTP 메서드를 통해 이를 처리한다.

### 장, 단점

- 장점
  - REST 기반으로 시스템을 분산시켜 확장성, 재사용성을 높여 유지보수와 운용을 쉽게 할 수 있게 만들어준다.
- 단점
  - API의 변경이 생길경우 backend에서 리소스를 변경해주기전까지 프론트앤드쪽에서 병목현상이 생긴다.
    - 하지만 이 이경우 swagger와 같은 API명세를 먼저 제공해서 Front-end에서 Mock-server와 같은 방법으로 동시 개발하여 문제를 해결할수있다

# 개념

## Class와 Interface, 객체란?

- Class
  - 객체를 만들어내기 위하여 상태와 행위(method)를 정의한 틀이다.
- Interface
  - 개발에서 청사진의 역할을 한다.
- 객체
  - 상태와 행위(method)를 가지고 있는 실체가 있는 데이터이다.

## Interface를 사용하는 이유는?

1. 결합도를 낮출수 있다.
2. 테스트의 용이성이 있다.
3. 개발을 독립적으로 할수있다.

- 추상 클래스의 다른점
  - 다중상속이 가능하다
  - 상태와 행위가 미완성 상태이다.

## DI란?

- 자기자신내에서 Class를 정의하는것이 아닌, 외부에서 객체를 주입하는 방법이다.
  - 생성자에서 Interface를 사용해서 객체를 매개변수로 받아서 사용할수 있게 만드는것이다.
- 이것을 사용하면 결합도를 낮출수있다.

## OOP란?

시스템을 여러 다양한 객체들의 집합으로 구성하는것이 객체지향 프로그래밍이다.
프로그램을 객체(object)라는 기본 단위로 나누고 객체들의 상호작용으로 기능들을 구현하는 방식이다.

## SOLID원칙이란?

### Single responsibilty

- 단일책임 원칙
- 객체 혹은 펑션은 한가지의 기능만 책임을 져야한다.

### Open-close

- 열림- 닫힘 원칙
- 확장에는 열려있어야 하지만, 변경하는것에는 닫혀있어야 한다.

### Liskov Substitution

- 리스코프 치환 원칙
- 객체의 상위타입의 객체를 하위타입의 객체로 사용해도 정상적으로 작동해야한다.
  - 객체의 상위타입 명세가 하위타입에서 적용될때에만 상속을 해야한다.

### Interface Segrearion

- 인터페이스 분리 원칙
- 인터페이스는 반드시 하나의 일을 해야 하며, 추가적인 행위는 반드시 별개의 인터페이스로 분리해서 추상화 시켜줘야한다.

### DI

- 의존성 역전
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
