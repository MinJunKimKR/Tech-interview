# Network

## https://www.google.com/ 을 접속할 때 일어나는 일

1. 브라우저가 입력한 URL을 파싱한다.
   이때 요청을 HTTP프로토콜을 사용해서 Request Message로 만든다.
2. 도메인으로는 요청을 할수없기에 IP주소를 찾는 작업을 실행한다.
3. 이때 Local에서 먼저 찾는데, 브라우저 ->hosts파일->DNScache순으로 탐색한다.
   만일 찾지 못했다면, DNS서버에 요청하여서 DNS Lookup을시행한다.
   이때 DNS Lookup은 루트도메인에서 서브도메인으로 찾는다
4. 브라우저가 IP를 이용해서 해당 서버와 통신하기 위해서 3 hand shake를 사용해서 TCP connection을 빌드한다.
5. 이떄, Https라면, SSL handshake를 추가적으로 하여 연결한다.
6. 이제, 요청을 OS에있는 프로토콜스택이라는 네트워크 제어용 소프트웨어에서 요청을 패킷으로 만든다.
7. LAN어댑터로 전송하고, 여기에서 패킷을 전기신호로 바꾼뒤 송출한다.
8. 라우터 ->ISP ->인터넷으로 빠져나간다.
9. 목적지에 도달하게되면, 방화벽의 검사를 받는다.
10. 캐시 서버로 전달하여 웹서버에 갈 필요가 있는지를 검사받는다.
11. 웹 서버 어플리케이션에 도달하면, 프로토콜스택으로 패킷에서 메세지가 추출된다.
12. 웹 서버 어Response를 작성한뒤에 왔던 경로대로 다시 보낸다.

<!-- 사용자가 입력한 URL 주소 중에서 도메인 네임(Domain Name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.
이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.
도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다. -->

# Data Structure

## 배열과 링크드 리스트의 차이점에 대해서 설명해 주세요.

**배열(Array)**

- 메모리에 할당될 때 연속적인 데이터 공간에 할당이 됩니다.
- 데이터에 접근할 때 random access가 가능하므로 빠르다.
- 삽입 삭제 시에나 배열의 크기를 유동적으로 변하기 어렵습니다.

**링크드 리스트(Linked list)**

- 메모리에 할당될 때 흩어져서 저장됩니다.
- 처음에 크기를 지정해주지 않아도되며 삽입 삭제가 빠르다.
- 검색시 순차접근을 통해서 접근해야하므로 느립니다.

## 해시테이블에 대해 설명해주세요

- key-value를 함께 저장하는 구조.
- key를 통해 value값을 얻어낸다.
- key, hash function, hash, value로 이루어짐.
- 서로 다른 키의 해시값이 동일하게 나오는 경우 해시 충돌이 일어난다.

### 장점

- 적은 리소스로 많은 데이터를 효율적으로 관리 가능.
- 배열 인덱스를 사용하므로 검색, 삽입, 삭제가 빠르다.

### 단점

- 충동 발생 가능성.
- 공간 복잡도 증가.
- 들어온 순서 무시.

### 해시 알고리즘

- chaining.
- 개방 주소법 - 선형조사, 2차조사, 이중 해싱.

## 그래프와 트리의 차이점에 대해서 설명해 주세요.

### 그래프

- 정점과 간선을 모아놓은 자료구조
- 연결되어있는 객체 각의 관계 표현가능
- 무방향/방향 가능
- self-loop, cycle가능
- ex) 지도, 지하철 노선도, 회로

### 트리

- 계층 구조를 가지는 그래프의 한 형태
- 하나의 루트 노드를 가짐
- loop, cycle 불가능

# CS

## Class와 Interface, 객체란?

- Class
  - 객체를 만들어내기 위하여 상태와 행위(method)를 정의한 틀이다.
- Interface
  - 개발에서 청사진의 역할을 한다.
- 객체
  - 상태와 행위(method)를 가지고 있는 실체가 있는 데이터이다.

## Interface를 사용하는 이유는?

1. 결합도를 낮출수 있다.
2. 테스트의 용이성이 있다.
3. 개발을 독립적으로 할수있다.

- 추상 클래스의 다른점
  - 다중상속이 가능하다
  - 상태와 행위가 미완성 상태이다.

## DI란?

- 자기자신내에서 Class를 정의하는것이 아닌, 외부에서 객체를 주입하는 방법이다.
  - 생성자에서 Interface를 사용해서 객체를 매개변수로 받아서 사용할수 있게 만드는것이다.
- 이것을 사용하면 결합도를 낮출수있다.

## SOLID원칙이란?

### Single responsibilty

- 단일책임 원칙
- 객체 혹은 펑션은 한가지의 기능만 책임을 져야한다.

### Open-close

- 열림- 닫힘 원칙
- 확장에는 열려있어야 하지만, 변경하는것에는 닫혀있어야 한다.

### Liskov Substitution

- 리스코프 치환 원칙
- 객체의 상위타입의 객체를 하위타입의 객체로 사용해도 정상적으로 작동해야한다.
  - 객체의 상위타입 명세가 하위타입에서 적용될때에만 상속을 해야한다.

### Interface Segrearion

- 인터페이스 분리 원칙
- 인터페이스는 반드시 하나의 일을 해야 하며, 추가적인 행위는 반드시 별개의 인터페이스로 분리해서 추상화 시켜줘야한다.

### DI

- 의존성 역전
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
