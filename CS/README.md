# Network

## https://www.google.com/ 을 접속할 때 일어나는 일

1. 브라우저가 입력한 URL을 파싱한다.
   이때 요청을 HTTP프로토콜을 사용해서 Request Message로 만든다.
2. 도메인으로는 요청을 할수없기에 IP주소를 찾는 작업을 실행한다.
3. 이때 Local에서 먼저 찾는데, 브라우저 ->hosts파일->DNScache순으로 탐색한다.
   만일 찾지 못했다면, DNS서버에 요청하여서 DNS Lookup을시행한다.
   이때 DNS Lookup은 루트도메인에서 서브도메인으로 찾는다
4. 브라우저가 IP를 이용해서 해당 서버와 통신하기 위해서 3 hand shake를 사용해서 TCP connection을 빌드한다.
5. 이떄, Https라면, SSL handshake를 추가적으로 하여 연결한다.
6. 이제, 요청을 OS에있는 프로토콜스택이라는 네트워크 제어용 소프트웨어에서 요청을 패킷으로 만든다.
7. LAN어댑터로 전송하고, 여기에서 패킷을 전기신호로 바꾼뒤 송출한다.
8. 라우터 ->ISP ->인터넷으로 빠져나간다.
9. 목적지에 도달하게되면, 방화벽의 검사를 받는다.
10. 캐시 서버로 전달하여 웹서버에 갈 필요가 있는지를 검사받는다.
11. 웹 서버 어플리케이션에 도달하면, 프로토콜스택으로 패킷에서 메세지가 추출된다.
12. 웹 서버 어Response를 작성한뒤에 왔던 경로대로 다시 보낸다.

<!-- 사용자가 입력한 URL 주소 중에서 도메인 네임(Domain Name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.
이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.
도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다. -->

## CORS

Reference list

https://evan-moon.github.io/2020/05/21/about-cors/

### CORS란

Cross Origin Resource Sharing의 줄임말 입니다.
서로 다른 출처로의 리소스요청을 제한하는것에 대한 정책이다.

따라서, Scheme, host, port가 동일하면 같은 출처라고 본다.

만약 우리가 **CORS 정책을 위반하는 리소스 요청**을 하더라도 해당 서버가 같은 출처에서 보낸 요청만 받겠다는 로직을 가지고 있는 경우가 아니라면 **서버는 정상적으로 응답**을 하고, 이후 **브라우저가 이 응답을 분석해서 CORS 정책 위반**이라고 판단되면 그 **응답을 사용하지 않고 그냥 버리는 순서**인 것이다.

CORS는 **브라우저의 구현 스펙**에 포함되는 정책이기 때문에, 브라우저를 통하지 않고 **서버 간 통신을 할 때는 이 정책이 적용되지 않는다.**

### CORS 동작법

다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되는데, 이때 **브라우저는 요청 헤더에 `Origin`이라는 필드에 요청을 보내는 출처**를 함께 담아보낸다.

이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 `Access-Control-Allow-Origin`이라는 값에
“**이 리소스를 접근하는 것이 허용된 출처**”를 내려준다.

이후 응답을 받은 브라우저는 자신이 보냈던 요청의 `Origin`과 서버가 보내준 응답의 `Access-Control-Allow-Origin`을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.

### CORS 정책 위반

1. 브라우저는 서버에게 fetch 요청을 보내기전에 option으로 예비 요청을 먼저 보낸다.
   ```
   OPTIONS https://evanmoon.tistory.com/rss
   ...
   Access-Control-Request-Headers: content-type
   Access-Control-Request-Method: GET
   ...
   Origin: https://evan-moon.github.io
   ...
   ```
   어떤 헤더를 사용할지, 어떤 요청을 보낼것인지 사전에 미리 서버측에 알려주고 있다.
2. 서버는 이 예비 요청에 대한 응답으로 현재 자신이 어떤 것들을 허용하고, 어떤 것들을 금지하고 있는지에 대한 정보를 응답 헤더에 담아서 브라우저에게 다시 보내주게 된다.

   ```
   OPTIONS https://evanmoon.tistory.com/rss 200 OK

   Access-Control-Allow-Origin: https://evanmoon.tistory.com
   ```

   `Access-Control-Allow-Origin`를 보면 서버는 이 리소스에 접근가능한 출처는 오직 `https://evanmoon.tistory.com` 뿐이라고 브라우저에 알려주는것이다.

3. 이 경우에 `https://evan-moon.github.io`에서 요청을 보낸것이기 때문에 CORS정책 위반이 일어나게된다.

중요한 것은 예비 요청의 성공/실패 여부가 아니라 “응답 헤더에 유효한 Access-Control-Allow-Origin 값이 존재하는가”이다. 만약 예비 요청이 실패해서 200이 아닌 상태 코드가 내려오더라도 헤더에 저 값이 제대로 들어가있다면 CORS 정책 위반이 아니라는 의미이다.

### CORS 해결방법

## Request의 종류

- pre-flight(프리플라이트)

  브라우저가 본 요청을 보내기 전에 보내는 `예비 요청을 Preflight`라고 부르는 것이며, 이 예비 요청에는 `HTTP 메소드 중 OPTIONS 메소드가 사용`된다.

  예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 이 요청을 보내는 것이 안전한지 확인하는 것이다.
  ![](https://evan-moon.github.io/static/c86699252752391939dc68f8f9a860bf/21b4d/cors-preflight.png)

  1. 예를들어 우리가 자바스크립트의 fetch API를 사용하여 브라우저에게 리소스를 받아오라는 명령을 내린다.
  2. 브라우저는 서버에게 fetch 요청을 보내기전에 option으로 예비 요청을 먼저 보낸다.
  3. 서버는 이 예비 요청에 대한 응답으로 현재 자신이 어떤 것들을 허용하고, 어떤 것들을 금지하고 있는지에 대한 정보를 응답 헤더에 담아서 브라우저에게 다시 보내주게 된다.
  4. 브라우저는 자신이 보낸 예비요청과 서버가 응답에 담아준 허용정책을 비교후, 이 요청을 보내는것이 안전하다 판단이 되면, 앤드포인트로 다시 본 요청을 보내게된다.
  5. 이후 서버가 이 본 요청에 응답하면 브라우저는 최종적으로 이 응답데이터를 자바스크립트에 넘기게 된다.

- simple

  단순 요청은 예비 요청을 보내지 않고 바로 서버에게 본 요청부터 때려박은 후, 서버가 이에 대한 응답의 헤더에 Access-Control-Allow-Origin과 같은 값을 보내주면 그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다.

  즉, 프리플라이트와 단순 요청 시나리오는 전반적인 로직 자체는 같되, 예비 요청의 존재 유무만 다르다.
  ![](https://evan-moon.github.io/static/d8ed6519e305c807c687032ff61240f8/21b4d/simple-request.png)

  다만, 이 경우 아래의 3개의 조건을 충족시켜야한다.

  1.  요청의 메소드는 GET, HEAD, POST 중 하나여야 한다.
  2.  Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안된다.
  3.  만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용된다.

  당장 사용자 인증에 사용되는 **Authorization 헤더 조차 저 조건에는 포함되지 않는다.**

  대부분의 **HTTP API는 text/xml이나 application/json 컨텐츠 타입**을 가지도록 설계되기 때문에 사실 상 이 조건들을 모두 만족시키는 상황을 만들기는 그렇게 쉽지 않은 것이 현실이다.

## HTTP 상태코드

# Data Structure

## 배열과 링크드 리스트의 차이점에 대해서 설명해 주세요.

**배열(Array)**

- 메모리에 할당될 때 연속적인 데이터 공간에 할당이 됩니다.
- 데이터에 접근할 때 random access가 가능하므로 빠르다.
- 삽입 삭제 시에나 배열의 크기를 유동적으로 변하기 어렵습니다.

**링크드 리스트(Linked list)**

- 메모리에 할당될 때 흩어져서 저장됩니다.
- 처음에 크기를 지정해주지 않아도되며 삽입 삭제가 빠르다.
- 검색시 순차접근을 통해서 접근해야하므로 느립니다.

## 해시테이블에 대해 설명해주세요

- key-value를 함께 저장하는 구조.
- key를 통해 value값을 얻어낸다.
- key, hash function, hash, value로 이루어짐.
- 서로 다른 키의 해시값이 동일하게 나오는 경우 해시 충돌이 일어난다.

### 장점

- 적은 리소스로 많은 데이터를 효율적으로 관리 가능.
- 배열 인덱스를 사용하므로 검색, 삽입, 삭제가 빠르다.

### 단점

- 충동 발생 가능성.
- 공간 복잡도 증가.
- 들어온 순서 무시.

### 해시 알고리즘

- chaining.
- 개방 주소법 - 선형조사, 2차조사, 이중 해싱.

## 그래프와 트리의 차이점에 대해서 설명해 주세요.

### 그래프

- 정점과 간선을 모아놓은 자료구조
- 연결되어있는 객체 각의 관계 표현가능
- 무방향/방향 가능
- self-loop, cycle가능
- ex) 지도, 지하철 노선도, 회로

### 트리

- 계층 구조를 가지는 그래프의 한 형태
- 하나의 루트 노드를 가짐
- loop, cycle 불가능

## Algoritm
